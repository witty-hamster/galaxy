# Java线程进阶

## :avocado: 【回顾】线程的基本概念

### 如何看进程与线程？

#### 进程

> 就是应用程序在内存中分配的空间，也就是正在运行的程序

- 特点
  - 各个进程之间互不干扰
  - 进程保存着程序每一个时刻运行的状态

> 示例：
>
> ​	杀毒软件APP、QQ APP、微信APP等，这些软件在运行时都是一个进程

#### CPU与进程之间如何作用

CPU采用时间片轮转的方式运行进程。CPU为每个进程分配一个时间段，称作它的时间片。

- 如果在**时间片结束时，进程还在运行**，则暂停整个进程的运行，并且**CPU分配给另一个进程**（这个过程叫做<b style="color:#009900">上下文切换</b>）
- 如果进程在时间片结束前阻塞或结束，则CPU立即进行切换，不用等待时间片用完
- 当进程暂停时，CPU会保存当前进程的状态（进程标识、进程使用的资源等），在下一次切换回来时，根据之前保存的状态进行恢复，接着继续执行

#### 线程

> 一个进程中的不同执行路径，也就是进程中的每一个子任务，都叫做线程
>
> 示例：
>
> ​	杀毒软件中既有杀毒功能、又有垃圾清理功能。这两个功能在分别对应杀毒软件进程中的两个线程

### 进程与线程之间的区别

> 进程让操作系统的并发成为了可能，而线程让进程内部并发成为了可能。两者共同作用，极大的提高了操作系统的性能

#### :thinking: 【思考】 多进程的方式也可以实现并发功能，但为什么我们要使用多线程呢？

多进程方式确实可以实现并发，但使用多线程，有以下几点优势：

- <b style="color:#ff0000">进程间的通信比较复杂，而线程间的通信比较简单</b>，通常情况下，我们需要使用<b style="color:#ff0000">共享资源</b>，这些资源在线程间的通信比较容易
- <b style="color:#ff0000">进程是重量级的，而线程是轻量级的</b>，故多线程方式的系统开销更小

由以上两点，我们可以看出，使用多线程方式更加优越

#### 进程和线程的区别

进程是一个独立的运行环境，而线程是在进程中执行的一个任务。

- **本质上**的区别是 —— <b style="color:#ff0000">是否单独占有内存地址空间及其他系统资源（比如：I/O）</b>
  - 进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂
  - 进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低
  - 进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小
- 另一个重要的区别 —— <b style="color:#ff0000">进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位（即CPU分配时间的单位）</b>

## :avocado: 【回顾】线程的创建方式、线程状态、线程常用方法

### 线程创建方式

> 线程创建时，均需要重写 run()方法，根据具体业务，在run()方法中写入具体的逻辑

创建方式有以下两种：

1. 创建类继承 Thread类
2. 创建类实现 Runnable接口

### 线程启动的方式

三种启动线程的方式：

1. 继承Thread类，直接new这个类，后调用start()方法
2. 实现Runnable接口，通过构造传入，后调用start()方法
3. 利用线程池

有时候也有说，启动线程的四种方式，除以上三种外，还有一个方式是根据第二种方式的变体。在创建Thread对象时，直接在构造体中传入Runnable匿名内部类（Lambda形式）

### 线程常用方法

1. `sleep()` 方法：线程休眠方法，参数为休眠时间，单位为毫秒ms
2. `yield()` 方法：线程主动退出资源方法，退出后会自动回到就绪队列中，之后会重新抢夺资源 {一般比较少使用}
3. `join()` 方法：线程加入方法，当前线程需要等待加入的线程执行完毕后，才能继续执行

:thinking: 【思考】如果需要保证两个线程顺序执行，怎么实现 ?

- 可以采用 `join()`方法，将一个线程加入到另一线程中，可保证两个线程的顺序执行

### :rainbow_flag: 线程状态

> 线程状态均由 JVM管理
>
> - 线程在程序执行过程中有6中状态。在宏观上有五态模型
>
> - 五态模型（参考下图）
>
>   - 新生 -> 就绪 -> 运行 -> 终止
>
>     ​				\  阻塞 /
>
> - 程序运行过程中的线程状态，可通过`java.lang.Thread.state`枚举类查看支持的线程状态有哪些
>
> - 线程执行过程中，可通过`Thread.getState()`获取线程状态

- 线程五态模型

  ![image-20220620190632704](images/image-20220620190632704.png)
  
- 线程状态迁移图

  ![image-20220727154800450](images/image-20220727154800450.png)

- 线程各状态说明

  - `NEW`：尚未启动的线程处于此状态。在new线程对象时，会处于此状态

  - `RUNNABLE`：可运行线程的线程状态。处于可运行状态的线程正在Java虚拟机中执行，但它可能正在等待来自操作系统的其他资源（例如，处理器）。此状态下还可分为两个内部小状态

    - `Ready`：就绪状态（线程从运行态被挂起、执行yield时，会变成就绪状态）
    - `Running`：运行状态（线程从就绪态被调度器选中后，便会变成运行态）

  - `BLOCKED`：线程阻塞等待监视器锁的线程状态。处于阻塞状态的线程正在等待监视器锁进入同步块/方法，或在调用`Object.wait()`后重新进入同步块/方法

    - 例如，由`synchronized`修饰的同步代码块或同步方法，未获取锁的线程处于当前状态

  - `WAITING`：等待线程的线程状态。由于调用以下方法之一，线程处于等待状态：

    - `Object.wait()` 没有超时
    - `Thread.join()` 没有超时
    - `LockSupport.park()`

    > 处于等待状态的线程正在等待另一个线程执行特定操作。例如：
    >
    > 1. 一个线程对对象调用`Object.wait()`正在等待另一个线程对该对象调用`Object.notify()`或`Object.notifyAll()`
    > 2. 已调用`Thread.join()`的线程正在等待指定线程终止

  - `TIMED_WAITING`：具有指定等待时间的等待线程的线程状态。由于以指定的等待时间调用以下方法之一，线程处于定时等待状态：

    - `Thread.sleep()`
    - `Object.wait()`
    - `Thread.join()`
    - `LockSupport.parkNanos()`
    - `LockSupport.parkUntil()`

  - `TERMINATED`：已终止线程的线程状态。线程以完成执行




### :lock: 锁（synchronized）

- 为什么要上锁？
  - 在并发编程中存在<b style="color:#ff0000">线程安全</b>问题，主要在以下两方面，会产生该问题：
    - 存在共享数据
    - 多线程共同操作共享数据
  - 使用关键字 `synchronized` 可以保证在同一时刻，只有一个线程可以执行某个方法或某个代码块，同时 `synchronized` 可以保证一个线程的变化可见（可见性），即可以代替 `volatile` 关键字

#### `synchronized` 实现原理

> HotSpot虚拟机是现在 Sun JDK 和 Open JDK 中所带的虚拟机，是目前使用范围最广的Java虚拟机

##### <b style="color:#0088ff">对象的组成</b>

在HotSpot虚拟机中，对象在内存中存储的布局可分为 3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充。

- <b style="color:#0088ff">实例数据</b>

  - 对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响，HotSpot虚拟机默认分配策略为 longs/doubles、ints、shorts\chars、bytes\booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起

- <b style="color:#0088ff">对齐填充</b>

  - 这部分并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全

- <b style="color:#0088ff">:star2::star2: 对象头</b>

  - 用于存储对象自身的运行时数据。Java对象头包含三部分，分别是Mark Word、Class Metadata Address、Array length。三部分内容说明

    - `Mark Word`：用来存储对象的 hashCode，GC分代年龄及锁信息
    - `Class Metadata Address`：用来存储对象类型的指针
    - `Array length`：用来存储数组对象的长度。如果对象不是数组类型，则没有 `Array length` 信息

  - synchronized 锁信息包括锁的标志和锁的状态，这些信息都存放在对象头的 Mark Word 这一部分

    ![](https://raw.githubusercontent.com/witty-hamster/assets/main/images/并发编程/HotSpot虚拟机中对象头结构.png)

  - Mark Word里默认数据是存储对象的HashCode等信息，但是会随着对象的运行改变而发生变化，不同的锁状态对应着不同的记录存储方式

    ![](https://raw.githubusercontent.com/witty-hamster/assets/main/images/并发编程/MarkWord中各类锁状态.png)

  - Synchronized 通常被称为重量级锁，它的早期设计并不包含锁升级机制，所以性能较差，那个时候只有无锁和有锁之分，但是1.6之后对其进行优化，为了减少获取锁和释放锁带来的性能消耗，新增了轻量级锁和偏向锁，所以需要重点关注这两种状态的原理，以及它们的区别

##### 锁的四种状态

在Java 6中，锁一共被分为4种状态，级别由低到高依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。随着线程竞争情况的升级，锁的状态会从无锁状态逐步升级到重量级锁状态。锁可以升级却不能降级，这种只能升不能降的策略，是为了提高效率









